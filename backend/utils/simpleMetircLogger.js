// utils/simpleMetricLogger.js (OMEGA MAGNU-X EDITION - High-Fidelity Metric Client)

const MetricClientConfig = {
    REPORTING_INTERVAL_MS: 5000, // Report metrics every 5 seconds
    MAX_BUFFER_SIZE: 1000,       // Max metrics to hold before forced flush
    ENDPOINT: 'http://metrics.provider.com/api/v1/metrics',
    // Global tags for every metric generated by this service instance
    GLOBAL_TAGS: { 
        service: 'biometric-client',
        environment: process.env.NODE_ENV || 'production'
    }
};

/**
 * Advanced MetricLogger supporting asynchronous reporting, tags (dimensions),
 * Counters, Gauges, and Histograms (summaries).
 */
class MetricLogger {
    constructor() {
        // Internal buffer to hold metric updates before flushing
        this.metricBuffer = [];
        this.intervalId = null;

        // Initialize and start the asynchronous reporter
        this.startReporter();
    }

    /**
     * Attaches global tags to a set of local tags.
     * @param {object} localTags - Tags specific to the current call.
     * @returns {string} A standardized, sortable tag string for aggregation.
     */
    _formatTags(localTags = {}) {
        const mergedTags = { ...MetricClientConfig.GLOBAL_TAGS, ...localTags };
        // Convert tags object to a sorted string key=value for stable aggregation
        return Object.keys(mergedTags)
            .sort()
            .map(key => `${key}=${mergedTags[key]}`)
            .join(',');
    }

    /**
     * Queues a metric to be sent in the next report cycle.
     * @param {string} type - 'counter', 'gauge', or 'histogram'.
     * @param {string} name - The metric name (e.g., 'biometric_success').
     * @param {number} value - The numeric value.
     * @param {object} tags - Optional tags/dimensions.
     */
    _queueMetric(type, name, value, tags) {
        if (this.metricBuffer.length >= MetricClientConfig.MAX_BUFFER_SIZE) {
            console.warn(`[MetricLogger] Buffer full (${this.metricBuffer.length}). Forcing immediate flush.`);
            this._flushMetrics();
        }

        const tagString = this._formatTags(tags);
        const timestamp = Date.now();

        this.metricBuffer.push({ type, name, value, tagString, timestamp });
    }

    // --- PUBLIC REPORTING METHODS ---

    /**
     * Tracks a count of events that occur over time (always positive).
     * @param {string} name 
     * @param {number} value - The increment amount (usually 1).
     * @param {object} tags 
     */
    reportCount(name, value = 1, tags) {
        this._queueMetric('counter', name, value, tags);
    }

    /**
     * Tracks the current value of a metric that can go up or down (e.g., active slots).
     * @param {string} name 
     * @param {number} value - The current value.
     * @param {object} tags 
     */
    reportGauge(name, value, tags) {
        this._queueMetric('gauge', name, value, tags);
    }

    /**
     * Tracks the distribution of values (e.g., latency, queue delay).
     * @param {string} name 
     * @param {number} value - The observation value (e.g., latency in ms).
     * @param {object} tags 
     */
    reportHistogram(name, value, tags) {
        this._queueMetric('histogram', name, value, tags);
    }

    // --- ASYNCHRONOUS FLUSHING ---

    /**
     * Worker function to group, aggregate, and send the metrics buffer.
     * @returns {Promise<void>}
     */
    async _flushMetrics() {
        if (this.metricBuffer.length === 0) {
            return;
        }

        // 1. Group and Aggregate Metrics (Crucial for performance and data integrity)
        const aggregatedData = this._aggregateMetrics();
        this.metricBuffer = []; // Clear the buffer immediately after aggregation

        try {
            // 2. Transmit Data (Simulated HTTP call)
            // In a real application, this would use a dedicated HTTP client (like Axios)
            // to send data in a standardized format (e.g., JSON or Prometheus text format).
            
            console.log(`[MetricLogger] Flushing ${Object.keys(aggregatedData).length} unique aggregated metrics.`);
            // const response = await fetch(MetricClientConfig.ENDPOINT, { /* ... options */ }); 
            
            // console.debug("Metrics sent:", aggregatedData);
            
            // The actual HTTP call simulation is skipped here for safety, but this
            // is the primary efficiency gain: async, batched I/O.

        } catch (error) {
            console.error(`[MetricLogger] Failed to send metrics to endpoint: ${error.message}`);
            // Note: For critical failures, metrics may be logged locally or simply dropped 
            // to prioritize service stability over metric collection.
        }
    }

    /**
     * Groups raw metric updates by (type, name, tags) and aggregates their values.
     * - Counters: Sum the values.
     * - Gauges: Keep the last recorded value (most recent timestamp).
     * - Histograms: Group observations into an array for upstream calculation (P95, P99).
     * @returns {object} An object containing aggregated metric entries.
     */
    _aggregateMetrics() {
        const aggregated = {};

        for (const metric of this.metricBuffer) {
            // Key = TYPE:NAME:TAGS_STRING (ensures uniqueness for aggregation)
            const key = `${metric.type}:${metric.name}:${metric.tagString}`;

            if (!aggregated[key]) {
                aggregated[key] = {
                    type: metric.type,
                    name: metric.name,
                    tags: metric.tagString,
                    data: metric.type === 'histogram' ? [] : 0, // Init data structure
                    timestamp: metric.timestamp
                };
            }

            switch (metric.type) {
                case 'counter':
                    aggregated[key].data += metric.value;
                    break;
                case 'gauge':
                    // Only take the value if it's newer (more recent timestamp)
                    if (metric.timestamp >= aggregated[key].timestamp) {
                        aggregated[key].data = metric.value;
                        aggregated[key].timestamp = metric.timestamp;
                    }
                    break;
                case 'histogram':
                    // Collect all observations for upstream processing
                    aggregated[key].data.push(metric.value);
                    break;
            }
        }
        return aggregated;
    }

    /**
     * Starts the reporting interval worker.
     */
    startReporter() {
        if (this.intervalId) {
            this.stopReporter();
        }
        this.intervalId = setInterval(() => {
            this._flushMetrics();
        }, MetricClientConfig.REPORTING_INTERVAL_MS);
        this.intervalId.unref(); // Allow the program to exit while the timer is running
        console.log(`[MetricLogger] Reporter started, flushing every ${MetricClientConfig.REPORTING_INTERVAL_MS}ms.`);
    }

    /**
     * Stops the reporting interval worker.
     */
    stopReporter() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = null;
            console.log("[MetricLogger] Reporter stopped.");
        }
    }
}

// Export a single, globally instantiated logger for easy module consumption
module.exports = new MetricLogger();